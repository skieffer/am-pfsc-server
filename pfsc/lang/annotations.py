# --------------------------------------------------------------------------- #
#   Proofscape Server                                                         #
#                                                                             #
#   Copyright (c) 2011-2022 Alpine Mathematics contributors                   #
#                                                                             #
#   Licensed under the Apache License, Version 2.0 (the "License");           #
#   you may not use this file except in compliance with the License.          #
#   You may obtain a copy of the License at                                   #
#                                                                             #
#       http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                             #
#   Unless required by applicable law or agreed to in writing, software       #
#   distributed under the License is distributed on an "AS IS" BASIS,         #
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
#   See the License for the specific language governing permissions and       #
#   limitations under the License.                                            #
# --------------------------------------------------------------------------- #

import json

from pfsc.lang.objects import PfscObj, Enrichment
from pfsc.build.lib.libpath import libpath_is_trusted
from pfsc.excep import PfscExcep, PECode
from pfsc.constants import IndexType
from pfsc.lang.freestrings import PfscJsonTransformer, json_parser, split_on_widgets, render_anno_markdown
from pfsc.lang.widgets import UnknownTypeWidget, MalformedWidget, WIDGET_TYPE_TO_CLASS, replace_data

class Annotation(Enrichment):
    """
    This class represents Proofscape annotations, as defined using the `anno`
    keyword in pfsc modules.

    It also conducts the parse-and-build process for annos, with support from
    functions and classes offered by the freestrings.py module. The basic outline
    of that process is:

      1. Split on widgets. The full text of the anno is split into alternating
         chunks of markdown and widget definitions.
      2. Build widgets (instances of subclasses of the Widget class) based on
         the widget definitions. In this process, names are supplied for any
         widgets lacking names, and a lookup is built, mapping names to widget
         instances.
      3. In order to generate the HTML for the annotation page, we:
         a. Regenerate the full text of the anno, but with each widget definition
            `<type:name>[label]{data}` replaced by a "widget stub" `[label]{name}`.
         b. This "stubtext" is then passed for Markdown rendering with a custom
            renderer, and along with our lookup mapping widget names to widgets.
            Besides doing ordinary Markdown rendering, the custom renderer transforms
            widget stubs into HTML by (i) applying ordinary Markdown on the `label`
            part, transforming that into `labelHTML`, and (ii) looking up the widget
            based on its `name`, passing `labelHTML` to the widget's `writeHTML`
            method, and substituting the returned HTML for the widget stub.
      4. The JSON for the annotation page is generated by simply iterating over
         our widget lookup, and building a new lookup, from widget UIDs to "widget
         data", i.e. dicts generated by the widgets' `writeData` methods.
    """

    def __init__(self, name, target_paths, text, module):
        Enrichment.__init__(self, 'annotation')
        self.parent = module
        self.name = name
        self.text = text
        self.find_and_store_targets(target_paths, module)
        self._trusted = None
        # Stuff we need to build:
        self.raw_parts = None
        self.Np = -1
        self.Nw = -1
        self.widget_lookup = {}
        self.widget_seq = []
        self.escaped_html = None
        self.anno_data = None
        self.textRange = None

    @property
    def trusted(self):
        if self._trusted is None:
            assert (libpath := self.getLibpath()) is not None
            self._trusted = libpath_is_trusted(libpath)
        return self._trusted

    def resolveLibpathsRec(self):
        for item in self.items.values():
            if callable(getattr(item, 'resolveLibpathsRec', None)):
                item.resolveLibpathsRec()

    def setTextRange(self, row0, col0, row1, col1):
        """
        Define the range in the module text over which this entity was defined.
        """
        self.textRange = (row0, col0, row1, col1)

    def getFirstRowNum(self):
        return None if self.textRange is None else self.textRange[0]

    def get_index_type(self):
        return IndexType.ANNO

    def build(self):
        """
        Split the text into chunks, find and build widgets.
        """
        # Start by "splitting on widgets". In other words, the full text of the annotation is split
        # into alternating chunks of non-widget text, and widget definitions. The list is always odd in
        # length, starting and ending with (possibly empty) non-widget text.
        # We store these original "chunks" before proceding to build Widget instances based on the
        # widget defn parts.
        self.raw_parts = split_on_widgets(self.text)
        parts = self.raw_parts
        # Number of parts:
        self.Np = len(parts)
        assert self.Np % 2 == 1
        # Number of widget defns:
        self.Nw = int((self.Np - 1) / 2)
        transformer = PfscJsonTransformer(scope=self)
        # Iterate over the widget defns:
        for k in range(self.Nw):
            # Each widget defn comes in the form of a RawWidgetData named tuple.
            rwd = parts[2*k+1]
            name = rwd.name
            # Do not allow duplicate names.
            if name in self.items:
                msg = "Name %s is defined twice in anno %s in module %s." % (
                    name, self.name, self.parent.getLibpath()
                )
                raise PfscExcep(msg, PECode.DUPLICATE_DEFINITION_IN_PFSC_MODULE)
            # Try to build a dictionary from the user-supplied JSON.
            try:
                tree = json_parser.parse(rwd.data)
                data = transformer.transform(tree)
            except Exception as err:
                # If any errors, make a MalformedWidget to display the error in HTML.
                widget = MalformedWidget(name, rwd.label, rwd.data, err, rwd.lineno)
            else:
                # Otherwise form the appropriate type of Widget.
                type_ = rwd.type.upper()
                # For unknown types we use the base Widget class, which writes a "dummy widget" HTML display.
                widgetClass = WIDGET_TYPE_TO_CLASS.get(type_, UnknownTypeWidget)
                # Form an instance of the appropriate widget subclass.
                widget = widgetClass(name, rwd.label, data, self, rwd.lineno)
                # Store it as an item in this Annotation.
                self[name] = widget
            # Store the widget in our widget lookup, whether it was malformed or not.
            # This is so that for every given widget definition, we have something
            # that can replace it with HTML.
            self.widget_lookup[name] = widget
            # We also store them in sequence.
            # I think Python dicts are now ordered, right?
            # I'm keeping the sequence anyway, just to not rely on that. Debatable design choice I suppose...
            self.widget_seq.append(widget)

    def get_widget_lookup(self):
        return self.widget_lookup

    def get_proper_widgets(self):
        return list(filter(
            lambda w: not isinstance(w, (MalformedWidget, UnknownTypeWidget)),
            self.widget_lookup.values()
        ))

    @staticmethod
    def format_raw_widget_data(rwd, data=None):
        if data is None:
            j = rwd.data
        else:
            j = json.dumps(data, indent=4)
        return '<%s:%s>[%s]%s' % (
            rwd.type, rwd.name, rwd.label, j
        )

    def write_anno_text(self, widget_data=None):
        """
        Write text to represent this annotation in a module, after substituting new widget data.

        :param widget_data: dict of the form {widgetpath:data_replacements} mapping widget libpaths
            a description of data replacements to be made.

            data_replacements itself is a dict, this time of the form {datapath:replacement}.

            Here each datapath is as described in the `replace_data` function defined in this module.
            The replacement is what should replace the item found at that datapath.

            If you want to replace the entire widget data, then you must define exactly one
            datapath:replacement pair, using the empty datapath.

        :return: the anno block text, with substitutions
        """
        if widget_data is None: widget_data = {}
        # First we prepare the lookup we need, mapping the names of widgets occurring within this
        # annotation, to the new data that is to be substituted for them, if any.
        lookup = {}
        annopath = self.getLibpath()
        annoprefix = annopath + '.'
        m = len(annoprefix)
        for widgetpath, data in widget_data.items():
            if widgetpath[:m] == annoprefix:
                widgetname = widgetpath[m:]
                lookup[widgetname] = data
        # Now we can assemble the desired text.
        raw = self.raw_parts
        text_parts = [raw[0]]
        for k in range(self.Nw):
            rwd, text = raw[2*k+1:2*k+3]
            data_replacements = lookup.get(rwd.name)
            if data_replacements:
                # First check for the special case in which the entire widget data is to be replaced.
                # This case is identified by the presence of a unique datapath of length zero in the
                # data_replacements lookup.
                key_list = list(data_replacements.keys())
                if len(key_list) == 1 and key_list[0] == '':
                    # We are replacing the entire widget data.
                    new_data = data_replacements['']
                else:
                    # We are not replacing the entire widget data.
                    new_data = json.loads(rwd.data)
                    replace_data(new_data, data_replacements.keys(), (lambda path, d, p: data_replacements[path]), accept_absent=True)
            else:
                new_data = None
            widget_text = self.format_raw_widget_data(rwd, data=new_data)
            text_parts.extend([widget_text, text])
        return ''.join(text_parts)

    def get_escaped_html(self, caching=True):
        """
        Get the escaped HTML for the notespage.

        :param caching: If True, the HTML will only be computed once, and stored.
        :return: The escaped HTML.
        """
        escaped_html = self.escaped_html
        if escaped_html is None or not caching:
            # Make a copy of the original raw parts.
            parts = self.raw_parts[:]
            # Substitute widget stubs for the widget parts.
            for k, widget in enumerate(self.widget_seq):
                parts[2 * k + 1] = f'[{widget.label}]{{{widget.name}}}'
            # Join it all together and compile markdown --> HTML.
            doc = ''.join(parts)
            escaped_html = render_anno_markdown(doc, self.widget_lookup, trusted=self.trusted)
            if caching: self.escaped_html = escaped_html
        return escaped_html

    def get_anno_data(self, caching=True):
        """
        Get the data for the notespage.

        :param caching: If True, the data will only be computed once, and stored.
        :return: The data.
        """
        anno_data = self.anno_data
        if anno_data is None or not caching:
            widget_data = {}
            for widget in self.widget_seq:
                if isinstance(widget, MalformedWidget): continue
                widget.enrich_data()
                uid = widget.writeUID()
                data = widget.writeData()
                widget_data[uid] = data
            anno_data = {
                'libpath': self.getLibpath(),
                'version': self.getVersion(),
                'widgets': widget_data,
            }
            if caching: self.anno_data = anno_data
        return anno_data

    def get_notespage_data(self, caching=True):
        """
        Get all the info for a notespage, bundled into one dict.
        """
        html = self.get_escaped_html(caching=caching)
        data = self.get_anno_data(caching=caching)
        return {
            "html": html,
            "data": data
        }
